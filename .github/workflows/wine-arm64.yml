name: Wine and Proton ARM64 Builder with FEX

on:
  schedule:
    # Proton 构建 - 每月1号和15号
    - cron: '0 0 1,15 * *'
    # Wine 构建 - 每月5号和20号
    - cron: '0 2 5,20 * *'
    # FEX 构建 - 每月10号和25号
    - cron: '0 4 10,25 * *'
  workflow_dispatch:
    inputs:
      build_type:
        description: '选择构建类型'
        required: true
        default: 'proton'
        type: choice
        options:
        - proton
        - wine-wow64
        - fex-emu
      proton_branch:
        description: 'Proton 分支 (仅 Proton 构建)'
        required: false
        default: 'proton_10.0'
        type: choice
        options:
        - proton_10.0
        - experimental_10.0
        - bleeding-edge
      wine_branch:
        description: 'Wine 分支 (仅 Wine 构建)'
        required: false
        default: 'staging'
        type: choice
        options:
        - vanilla
        - staging
        - staging-tkg
        - staging-tkg-fsync
      wine_version:
        description: 'Wine 版本 (仅 Wine 构建)'
        required: false
        default: 'latest'
        type: string

env:
  USE_CCACHE: true
  BUILD_DIR: /tmp/build_wine
  FEX_COMMIT: 4afbdd9afb4738b2abbf303493c5b67f58b8ae4c

permissions:
  contents: write  # 允许 GITHUB_TOKEN 创建 Release

jobs:
  build-fex:
    runs-on: ubuntu-24.04-arm
    if: github.event.inputs.build_type == 'fex-emu' || (github.event_name == 'schedule' && github.event.schedule == '0 4 10,25 * *')
    
    steps:
    - name: Checkout FEX repository
      uses: actions/checkout@v4
      with:
        repository: FEX-Emu/FEX
        ref: ${{ env.FEX_COMMIT }}
        submodules: recursive
        path: fex-source

    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          cmake \
          clang \
          git \
          lld \
          llvm \
          llvm-dev \
          ninja-build \
          python3 \
          nasm \
          python3-clang \
          catch2 \
          libfmt-dev \
          libepoxy-dev \
          libsdl2-dev \
          libxxhash-dev \
          libasound2-dev \
          libdrm-dev \
          libgl1-mesa-dev \
          libx11-dev \
          libxrandr-dev \
          libssl-dev \
          libwayland-dev \
          zlib1g-dev

    - name: Download and extract llvm-mingw
      run: |
        wget -O llvm-mingw.tar.xz https://github.com/bylaws/llvm-mingw/releases/download/20250920/llvm-mingw-20250920-ucrt-ubuntu-22.04-aarch64.tar.xz
        tar -xf llvm-mingw.tar.xz -C /tmp

    - name: Build FEX-Emu for ARM64
      run: |
        set -e
        echo "开始构建 FEX-Emu for ARM64..."
        
        export PATH="/tmp/llvm-mingw-20250920-ucrt-ubuntu-22.04-aarch64/bin:$PATH"
        export CFLAGS="-O3 -g -pipe -Wall -Wextra"
        export CXXFLAGS="$CFLAGS"
        export LDFLAGS="-Wl,--gc-sections"
        
        cd fex-source
        
        # 直接构建 WOW64 版本（ARM64）
        echo "=== 构建 WOW64 版本 ==="
        mkdir build-wow64 && cd build-wow64
        
        cmake -DCMAKE_C_FLAGS="$CFLAGS" -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
          -GNinja \
          -DCMAKE_INSTALL_PREFIX=/usr \
          -DCMAKE_INSTALL_LIBDIR=lib/wine/aarch64-windows \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_TOOLCHAIN_FILE=../Data/CMake/toolchain_mingw.cmake \
          -DENABLE_LTO=False \
          -DTUNE_CPU=none \
          -DMINGW_TRIPLE=aarch64-w64-mingw32 \
          -DBUILD_TESTING=False \
          -DENABLE_JEMALLOC_GLIBC_ALLOC=OFF \
          ..
        
        # 修复 dlltool 命令
        if [ -f "build.ninja" ]; then
          sed -i 's/aarch64-w64-mingw32-dlltool/llvm-dlltool -m arm64/g' build.ninja
          ninja
        else
          echo "错误: build.ninja 文件未生成"
          exit 1
        fi
        
        cd ..
        
        echo "FEX-Emu WOW64 构建完成"

    - name: Install FEX artifacts
      run: |
        mkdir -p artifacts
        # 复制构建的 DLL 文件
        if [ -f "fex-source/build-wow64/libwow64fex.dll" ]; then
          cp fex-source/build-wow64/libwow64fex.dll artifacts/
          echo "已复制 libwow64fex.dll"
        else
          echo "错误: libwow64fex.dll 不存在"
          exit 1
        fi
        
        # 复制许可证和文档
        cp fex-source/LICENSE artifacts/
        cp fex-source/Readme.md artifacts/

    - name: Upload FEX artifacts
      uses: actions/upload-artifact@v4
      with:
        name: fex-emu-wow64-dll
        path: artifacts/
        retention-days: 30

    - name: 发布 FEX 到 GitHub Release
      uses: softprops/action-gh-release@v1
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_type == 'fex-emu'
      with:
        tag_name: fex-emu-wow64-${{ env.FEX_COMMIT }}
        name: FEX-Emu WOW64 DLL (${{ env.FEX_COMMIT }})
        body: |
          # FEX-Emu WOW64 DLL for ARM64
          
          ## 版本信息
          - **提交**: ${{ env.FEX_COMMIT }}
          - **架构**: WOW64 (ARM64)
          - **平台**: Wine on ARM64
          
          ## 包含文件
          - `libwow64fex.dll` - WOW64 版本
          
          ## 用途
          这个 DLL 文件用于在 ARM64 设备上通过 Wine 运行 x86/x64 Windows 应用程序。
          
          ## 安装说明
          将 DLL 文件放置在 Wine 的相应系统目录中。
          
          ## 构建信息
          - 构建时间: ${{ github.event.head_commit.timestamp }}
          - 提交: ${{ env.FEX_COMMIT }}
          - 工作流: ${{ github.workflow }}
          
          ## 注意
          - 这是纯 ARM64 构建，不包含 ARM64EC
          - 移除了复杂的补丁步骤，构建更稳定
        files: |
          ${{ github.workspace }}/artifacts/*
        draft: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-proton:
    runs-on: ubuntu-24.04-arm
    if: github.event.inputs.build_type == 'proton' || (github.event_name == 'schedule' && github.event.schedule == '0 0 1,15 * *')
    timeout-minutes: 360
    
    steps:
      - uses: actions/checkout@v4

      - name: 修复包管理系统
        run: |
          sudo apt clean
          sudo apt autoclean
          sudo apt autoremove -y
          sudo dpkg --configure -a
          sudo apt update --fix-missing

      - name: 安装构建依赖
        run: |
          sudo apt update
          
          # 修复包依赖问题
          sudo apt --fix-broken install -y
          sudo apt install -f -y
          
          # 添加 32 位架构支持
          sudo dpkg --add-architecture armhf
          sudo apt update
          
          # 基础构建依赖
          BASE_DEPS="\
            debootstrap \
            perl \
            git \
            wget \
            curl \
            xz-utils \
            bubblewrap \
            autoconf \
            automake \
            autotools-dev \
            flex \
            bison \
            gcc \
            g++ \
            build-essential \
            cmake \
            ninja-build \
            pkg-config \
            libtool \
            libx11-dev \
            libx11-dev:armhf \
            libxext-dev \
            libxext-dev:armhf \
            libxi-dev \
            libxi-dev:armhf \
            libxrandr-dev \
            libxrandr-dev:armhf \
            libxcursor-dev \
            libxcursor-dev:armhf \
            libxcomposite-dev \
            libxcomposite-dev:armhf \
            libxdamage-dev \
            libxdamage-dev:armhf \
            libxfixes-dev \
            libxfixes-dev:armhf \
            libxxf86vm-dev \
            libxxf86vm-dev:armhf \
            libxrender-dev \
            libxrender-dev:armhf \
            libxinerama-dev \
            libxinerama-dev:armhf \
            libgl-dev \
            libgl-dev:armhf \
            libglu-dev \
            libglu-dev:armhf \
            libosmesa6-dev \
            libosmesa6-dev:armhf \
            libfreetype6-dev \
            libfreetype6-dev:armhf \
            libfontconfig1-dev \
            libfontconfig1-dev:armhf \
            libpcap-dev \
            libdbus-1-dev \
            libdbus-1-dev:armhf \
            libssl-dev \
            libssl-dev:armhf \
            libasound2-dev \
            libasound2-dev:armhf \
            libpulse-dev \
            libpulse-dev:armhf \
            libudev-dev \
            libudev-dev:armhf \
            libcups2-dev \
            libcups2-dev:armhf \
            libjpeg-dev \
            libjpeg-dev:armhf \
            libpng-dev \
            libpng-dev:armhf \
            libtiff-dev \
            libtiff-dev:armhf \
            libxml2-dev \
            libxml2-dev:armhf \
            libvulkan-dev \
            libvulkan-dev:armhf \
            vulkan-tools \
            libvulkan1 \
            libvulkan1:armhf \
            mesa-vulkan-drivers \
            gettext \
            libgettextpo-dev \
            libgettextpo-dev:armhf \
            locales \
            language-pack-zh-hans"
          
          # 逐个安装包
          for pkg in $BASE_DEPS; do
            echo "安装包: $pkg"
            sudo apt install -y --allow-downgrades --allow-remove-essential --allow-change-held-packages "$pkg" || echo "跳过有问题的包: $pkg"
          done

          # 安装交叉编译工具链（在 ARM64 上编译 32 位 ARM）
          CROSS_DEPS="\
            gcc-arm-linux-gnueabihf \
            g++-arm-linux-gnueabihf \
            binutils-arm-linux-gnueabihf"
          
          sudo apt install -y $CROSS_DEPS

      - name: 安装 GStreamer 开发依赖
        run: |
          sudo apt update
          
          # 安装完整的 GStreamer 开发文件 (64位和32位)
          echo "安装 GStreamer 开发依赖..."
          
          # 先安装基础包
          sudo apt install -y \
            gstreamer1.0-tools \
            gstreamer1.0-plugins-base \
            gstreamer1.0-plugins-base:armhf \
            gstreamer1.0-plugins-good \
            gstreamer1.0-plugins-good:armhf \
            gstreamer1.0-plugins-bad \
            gstreamer1.0-plugins-bad:armhf \
            gstreamer1.0-plugins-ugly \
            gstreamer1.0-plugins-ugly:armhf \
            gstreamer1.0-libav \
            gstreamer1.0-libav:armhf
          
          # 安装开发文件
          GST_DEV_DEPS="\
            libgstreamer1.0-dev \
            libgstreamer1.0-dev:armhf \
            libgstreamer-plugins-base1.0-dev \
            libgstreamer-plugins-base1.0-dev:armhf \
            libgstreamer-plugins-good1.0-dev \
            libgstreamer-plugins-good1.0-dev:armhf \
            libgstreamer-plugins-bad1.0-dev \
            libgstreamer-plugins-bad1.0-dev:armhf"
          
          for pkg in $GST_DEV_DEPS; do
            echo "安装 GStreamer 开发包: $pkg"
            sudo apt install -y --allow-downgrades --allow-remove-essential --allow-change-held-packages "$pkg" || echo "跳过有问题的包: $pkg"
          done
          
          # 安装多媒体编解码器开发文件
          CODEC_DEV_DEPS="\
            libmpg123-dev \
            libmpg123-dev:armhf \
            libopenal-dev \
            libopenal-dev:armhf \
            libfaad-dev \
            libfaad-dev:armhf \
            libflac-dev \
            libflac-dev:armhf \
            libvorbis-dev \
            libvorbis-dev:armhf \
            libx264-dev \
            libx264-dev:armhf \
            libx265-dev \
            libx265-dev:armhf \
            libvpx-dev \
            libvpx-dev:armhf \
            libtheora-dev \
            libtheora-dev:armhf \
            libavcodec-dev \
            libavcodec-dev:armhf \
            libavformat-dev \
            libavformat-dev:armhf \
            libavutil-dev \
            libavutil-dev:armhf \
            libswscale-dev \
            libswscale-dev:armhf"
          
          for pkg in $CODEC_DEV_DEPS; do
            echo "安装编解码器开发包: $pkg"
            sudo apt install -y --allow-downgrades --allow-remove-essential --allow-change-held-packages "$pkg" || echo "跳过有问题的包: $pkg"
          done
          
          echo "GStreamer 依赖安装完成"

      - name: 修复 GStreamer pkgconfig 问题
        run: |
          echo "修复 GStreamer pkgconfig 问题..."
          
          # 查找所有可能的 pkgconfig 目录
          echo "查找所有 GStreamer pkgconfig 文件..."
          find /usr -name "*.pc" 2>/dev/null | grep gstreamer | head -10
          
          # 检查 64 位 gstreamer-plugins-base-1.0.pc 是否存在
          if [ ! -f "/usr/lib/aarch64-linux-gnu/pkgconfig/gstreamer-plugins-base-1.0.pc" ]; then
            echo "64 位 gstreamer-plugins-base-1.0.pc 不存在，尝试修复..."
            
            # 查找可能的位置
            ALT_LOCATION=$(find /usr -name "gstreamer-plugins-base-1.0.pc" 2>/dev/null | grep -v arm-linux-gnueabihf | head -1)
            if [ -n "$ALT_LOCATION" ]; then
              echo "在其他位置找到: $ALT_LOCATION"
              # 创建符号链接
              sudo mkdir -p /usr/lib/aarch64-linux-gnu/pkgconfig
              sudo ln -sf "$ALT_LOCATION" "/usr/lib/aarch64-linux-gnu/pkgconfig/gstreamer-plugins-base-1.0.pc"
              echo "已创建符号链接"
            else
              echo "错误: 无法找到 64 位 gstreamer-plugins-base-1.0.pc 文件"
              # 尝试重新安装包
              sudo apt install --reinstall -y libgstreamer-plugins-base1.0-dev
            fi
          fi
          
          # 验证修复结果
          echo "验证修复后的 GStreamer pkgconfig:"
          PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig" pkg-config --exists gstreamer-plugins-base-1.0 && echo "gstreamer-plugins-base-1.0 找到" || echo "gstreamer-plugins-base-1.0 未找到"

      - name: 验证 GStreamer 安装
        run: |
          echo "验证 GStreamer 开发文件..."
          
          # 设置完整的 PKG_CONFIG_PATH
          export PKG_CONFIG_PATH_64="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
          export PKG_CONFIG_PATH_32="/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
          
          echo "检查 64 位 GStreamer 开发文件:"
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_64" pkg-config --cflags gstreamer-1.0
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_64" pkg-config --cflags gstreamer-plugins-base-1.0
          
          echo "检查 32 位 GStreamer 开发文件:"
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_32" pkg-config --cflags gstreamer-1.0
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_32" pkg-config --cflags gstreamer-plugins-base-1.0

      - name: 安装 SDL2 开发依赖
        run: |
                sudo apt update
                echo "安装 SDL2 开发文件..."
    
                # 安装 SDL2 开发包（64位和32位）
                sudo apt install -y \
                  libsdl2-dev \
                  libsdl2-dev:armhf \
                  libsdl2-2.0-0 \
                  libsdl2-2.0-0:armhf \
                  libsdl2-image-dev \
                  libsdl2-image-dev:armhf \
                  libsdl2-ttf-dev \
                  libsdl2-ttf-dev:armhf \
                  libsdl2-mixer-dev \
                  libsdl2-mixer-dev:armhf
    
                echo "验证 SDL2 安装..."
                pkg-config --cflags sdl2
                pkg-config --libs sdl2

      - name: 设置交叉编译环境
        run: |
          # 创建交叉编译工具链符号链接
          sudo ln -sf /usr/bin/arm-linux-gnueabihf-gcc /usr/local/bin/arm-linux-gnueabihf-gcc
          sudo ln -sf /usr/bin/arm-linux-gnueabihf-g++ /usr/local/bin/arm-linux-gnueabihf-g++
          
          # 验证工具链
          echo "验证交叉编译工具链:"
          arm-linux-gnueabihf-gcc --version

      - name: 设置中文语言环境
        run: |
          sudo locale-gen zh_CN.UTF-8
          sudo update-locale LANG=zh_CN.UTF-8
          export LANG=zh_CN.UTF-8
          export LC_ALL=zh_CN.UTF-8

      - name: 设置编译环境
        run: |
          # 设置更宽松的 ulimit
          ulimit -s unlimited
          ulimit -n 65536
          
          # 显示系统资源
          echo "系统资源:"
          free -h
          df -h
          nproc
          cat /proc/meminfo | grep MemTotal

      - name: 构建 Proton ARM64 WOW64 版本
        run: |
            set -e
            
            echo "开始构建 Proton ARM64 WOW64 版本..."
            echo "分支: ${{ github.event.inputs.proton_branch || 'proton_10.0' }}"
            
            # 设置构建名称
            BUILD_NAME="proton-${{ github.event.inputs.proton_branch || 'proton_10.0' }}-arm64-wow64-xuser"
            echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
            
            # 设置中文构建环境
            export LANG=zh_CN.UTF-8
            export LC_ALL=zh_CN.UTF-8
            export LANGUAGE=zh_CN:zh:en_US:en
            
            # 清理并创建构建目录
            rm -rf $BUILD_DIR/proton
            mkdir -p $BUILD_DIR/proton
            cd $BUILD_DIR/proton
            
            # 克隆 Proton 源码
            git clone https://github.com/afeimod/wine
            cd wine
            
            # 生成 configure 脚本
            echo "生成 configure 脚本..."
            ./autogen.sh
            
            # 第一步：构建 64 位 Wine
            echo "=== 构建 64 位 Wine ==="
            mkdir -p build64
            cd build64
            
            # 使用原生编译器
            export CC=gcc
            export CXX=g++
            export CFLAGS="-march=armv8-a+crc+crypto -O3 -g -pipe -Wall -Wextra -fPIC"
            export CXXFLAGS="-march=armv8-a+crc+crypto -O3 -g -pipe -Wall -Wextra -fPIC"
            export MAKEFLAGS="-j2"
            
            # 设置完整的 PKG_CONFIG_PATH
            export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
            
            echo "PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
            echo "测试 GStreamer pkg-config:"
            pkg-config --cflags gstreamer-1.0 || echo "gstreamer-1.0 未找到"
            pkg-config --cflags gstreamer-plugins-base-1.0 || echo "gstreamer-plugins-base-1.0 未找到"
            
            # 配置 64 位 Wine - 使用原生配置
            ../configure \
              --prefix=/tmp/wine-install-proton \
              --enable-win64 \
              --with-x \
              --with-alsa \
              --with-pulse \
              --with-freetype \
              --with-fontconfig \
              --with-gstreamer \
              --with-gettext \
              --with-sdl \
              --enable-nls \
              --disable-winemenubuilder \
              --disable-win16 \
              --disable-tests \
              --without-ldap \
              --without-capi \
              --without-oss \
              --without-cups \
              --without-dbus \
              --without-coreaudio \
              --without-gphoto \
              --without-osmesa \
              --without-sane \
              --without-pcap \
              --without-pcsclite \
              --without-udev \
              --without-unwind \
              --without-usb \
              --without-v4l2 \
              --without-wayland
            
            echo "编译 64 位 Wine..."
            make -j2 install > make64.log 2>&1 || (echo "64位编译失败，查看日志..." && tail -100 make64.log && make -j1 install > make64_single.log 2>&1 || (tail -100 make64_single.log && exit 1))
            
            cd ..
            
            # 第二步：构建 32 位 Wine
            echo "=== 构建 32 位 Wine ==="
            mkdir -p build32
            cd build32
            
            # 对于 32 位构建，使用交叉编译器
            export CC=arm-linux-gnueabihf-gcc
            export CXX=arm-linux-gnueabihf-g++
            export CFLAGS="-march=armv8-a -O3 -g -pipe -Wall -Wextra -fPIC"
            export CXXFLAGS="-march=armv8-a -O3 -g -pipe -Wall -Wextra -fPIC"
            export MAKEFLAGS="-j2"
            
            # 设置 32 位的 PKG_CONFIG_PATH
            export PKG_CONFIG_PATH="/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
            export PKG_CONFIG="pkg-config --define-variable=libdir=/usr/lib/arm-linux-gnueabihf"
            
            echo "PKG_CONFIG_PATH for 32-bit: $PKG_CONFIG_PATH"
            echo "测试 GStreamer pkg-config:"
            pkg-config --cflags gstreamer-1.0 || echo "gstreamer-1.0 未找到"
            pkg-config --cflags gstreamer-plugins-base-1.0 || echo "gstreamer-plugins-base-1.0 未找到"
            
            # 配置 32 位 Wine，指向已安装的 64 位版本
            ../configure \
              --build=arm-linux-gnueabihf \
              --host=arm-linux-gnueabihf \
              --with-wine64=../build64 \
              --with-x \
              --with-alsa \
              --with-pulse \
              --with-freetype \
              --with-fontconfig \
              --with-gstreamer \
              --disable-winemenubuilder \
              --disable-win16 \
              --disable-tests \
              --without-ldap \
              --without-capi \
              --without-oss \
              --without-cups \
              --without-dbus \
              --without-coreaudio \
              --without-gphoto \
              --without-osmesa \
              --without-sane \
              --without-pcap \
              --without-pcsclite \
              --without-udev \
              --without-unwind \
              --without-usb \
              --without-v4l2 \
              --without-wayland
            
            echo "编译 32 位 Wine..."
            make -j2 install > make32.log 2>&1 || (echo "32位编译失败，查看日志..." && tail -100 make32.log && make -j1 install > make32_single.log 2>&1 || (tail -100 make32_single.log && exit 1))
            
            echo "ARM64 WOW64 Wine 构建完成"

      - name: 准备打包
        run: |
          # 创建打包目录
          PACKAGE_NAME="${{ env.BUILD_NAME }}"
          mkdir -p wine-package/$PACKAGE_NAME
          
          # 检查源目录是否存在
          if [ -d "/tmp/wine-install-proton" ]; then
            echo "复制 Wine 文件到 $PACKAGE_NAME..."
            cp -r /tmp/wine-install-proton/* wine-package/$PACKAGE_NAME/ || echo "复制文件时出现问题"
          else
            echo "错误: 源目录 /tmp/wine-install-proton 不存在"
            exit 1
          fi

      - name: 创建打包文件
        run: |
          PACKAGE_NAME="${{ env.BUILD_NAME }}"
          
          echo "检查打包目录内容:"
          if [ -d "wine-package/$PACKAGE_NAME" ]; then
            echo "最终文件结构:"
            find "wine-package/$PACKAGE_NAME" -type f | head -20
            echo "目录大小:"
            du -sh "wine-package/$PACKAGE_NAME"
            
            # 使用 tar.xz 格式打包
            tar -cJf "$PACKAGE_NAME.tar.xz" -C wine-package "$PACKAGE_NAME"
            
            echo "打包完成:"
            ls -lh *.tar.xz
          else
            echo "错误: 打包目录 wine-package/$PACKAGE_NAME 不存在"
            exit 1
          fi

      - name: Generate checksums
        run: |
          cd $GITHUB_WORKSPACE
          sha256sum *.tar.xz > checksums.txt
          cat checksums.txt

      - name: Upload Proton artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Proton-${{ github.event.inputs.proton_branch || 'proton_10.0' }}-ARM64-WoW64-xuser
          path: |
            ${{ github.workspace }}/*.tar.xz
            ${{ github.workspace }}/checksums.txt
          retention-days: 30

      - name: 发布 Proton 到 GitHub Release
        uses: softprops/action-gh-release@v1
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_type == 'proton'
        with:
          tag_name: proton-${{ github.event.inputs.proton_branch || 'proton_10.0' }}-arm64-wow64-xuser
          name: Proton ${{ github.event.inputs.proton_branch || 'proton_10.0' }} (ARM64 WOW64 with Vulkan & GStreamer for Termux - xuser)
          body: |
            # Proton ${{ github.event.inputs.proton_branch || 'proton_10.0' }} - ARM64 WOW64 with Vulkan & GStreamer for Termux (xuser)
            
            ## 版本信息
            - **Proton 分支**: ${{ github.event.inputs.proton_branch || 'proton_10.0' }}
            - **架构**: ARM64 WOW64 (在 ARM64 设备上运行 32 位和 64 位 Windows 应用程序)
            - **平台**: Termux (Android ARM64)
            - **图形 API**: Vulkan 支持已启用
            - **多媒体**: 完整 GStreamer 支持
            - **用户名**: xuser (已移除 Steam 优化)
            
            ## 特性
            ✓ ARM64 原生架构
            ✓ WOW64 支持 (在 ARM64 上运行 32 位和 64 位 Windows 应用程序)
            ✓ Vulkan 图形 API 支持
            ✓ 完整的 GStreamer 支持
            ✓ 中文环境支持
            ✓ 基于 Valve Proton，但移除了 Steam 特定优化
            ✓ 默认用户名改为 xuser
            ✓ 针对 ARM64 架构优化编译
            
            ## 重要变更
            - 所有对 `steamuser` 的引用已改为 `xuser`
            - 移除了 Steam 特定的优化和组件
            - 更适合通用 Windows 应用程序运行
            - 针对 ARM64 架构优化
            
            ## 安装说明
            解压后，将 `${{ env.BUILD_NAME }}` 文件夹放置在 Termux 的合适位置，并设置环境变量。

            ## 构建信息
            - 构建时间: ${{ github.event.head_commit.timestamp }}
            - 提交: ${{ github.sha }}
            - 工作流: ${{ github.workflow }}
          files: |
            ${{ github.workspace }}/*.tar.xz
            ${{ github.workspace }}/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-wine-wow64:
    runs-on: ubuntu-24.04-arm
    if: github.event.inputs.build_type == 'wine-wow64' || (github.event_name == 'schedule' && github.event.schedule == '0 2 5,20 * *')
    timeout-minutes: 360
    
    steps:
      - uses: actions/checkout@v4
      
      - name: 修复包管理系统
        run: |
          sudo apt clean
          sudo apt autoclean
          sudo apt autoremove -y
          sudo dpkg --configure -a
          sudo apt update --fix-missing

      - name: 安装构建依赖
        run: |
          sudo apt update
          
          # 修复包依赖问题
          sudo apt --fix-broken install -y
          sudo apt install -f -y
          
          # 添加 32 位架构支持
          sudo dpkg --add-architecture armhf
          sudo apt update
          
          # 基础构建依赖
          BASE_DEPS="\
            debootstrap \
            perl \
            git \
            wget \
            curl \
            xz-utils \
            bubblewrap \
            autoconf \
            automake \
            autotools-dev \
            flex \
            bison \
            gcc \
            g++ \
            build-essential \
            cmake \
            ninja-build \
            pkg-config \
            libtool \
            libx11-dev \
            libx11-dev:armhf \
            libxext-dev \
            libxext-dev:armhf \
            libxi-dev \
            libxi-dev:armhf \
            libxrandr-dev \
            libxrandr-dev:armhf \
            libxcursor-dev \
            libxcursor-dev:armhf \
            libxcomposite-dev \
            libxcomposite-dev:armhf \
            libxdamage-dev \
            libxdamage-dev:armhf \
            libxfixes-dev \
            libxfixes-dev:armhf \
            libxxf86vm-dev \
            libxxf86vm-dev:armhf \
            libxrender-dev \
            libxrender-dev:armhf \
            libxinerama-dev \
            libxinerama-dev:armhf \
            libgl-dev \
            libgl-dev:armhf \
            libglu-dev \
            libglu-dev:armhf \
            libosmesa6-dev \
            libosmesa6-dev:armhf \
            libfreetype6-dev \
            libfreetype6-dev:armhf \
            libfontconfig1-dev \
            libfontconfig1-dev:armhf \
            libpcap-dev \
            libdbus-1-dev \
            libdbus-1-dev:armhf \
            libssl-dev \
            libssl-dev:armhf \
            libasound2-dev \
            libasound2-dev:armhf \
            libpulse-dev \
            libpulse-dev:armhf \
            libudev-dev \
            libudev-dev:armhf \
            libcups2-dev \
            libcups2-dev:armhf \
            libjpeg-dev \
            libjpeg-dev:armhf \
            libpng-dev \
            libpng-dev:armhf \
            libtiff-dev \
            libtiff-dev:armhf \
            libxml2-dev \
            libxml2-dev:armhf \
            libvulkan-dev \
            libvulkan-dev:armhf \
            vulkan-tools \
            libvulkan1 \
            libvulkan1:armhf \
            mesa-vulkan-drivers \
            gettext \
            libgettextpo-dev \
            libgettextpo-dev:armhf \
            locales \
            language-pack-zh-hans"
          
          # 逐个安装包
          for pkg in $BASE_DEPS; do
            echo "安装包: $pkg"
            sudo apt install -y --allow-downgrades --allow-remove-essential --allow-change-held-packages "$pkg" || echo "跳过有问题的包: $pkg"
          done

          # 安装交叉编译工具链（在 ARM64 上编译 32 位 ARM）
          CROSS_DEPS="\
            gcc-arm-linux-gnueabihf \
            g++-arm-linux-gnueabihf \
            binutils-arm-linux-gnueabihf"
          
          sudo apt install -y $CROSS_DEPS

      - name: 安装 GStreamer 开发依赖
        run: |
          sudo apt update
          
          # 安装完整的 GStreamer 开发文件 (64位和32位)
          echo "安装 GStreamer 开发依赖..."
          
          # 先安装基础包
          sudo apt install -y \
            gstreamer1.0-tools \
            gstreamer1.0-plugins-base \
            gstreamer1.0-plugins-base:armhf \
            gstreamer1.0-plugins-good \
            gstreamer1.0-plugins-good:armhf \
            gstreamer1.0-plugins-bad \
            gstreamer1.0-plugins-bad:armhf \
            gstreamer1.0-plugins-ugly \
            gstreamer1.0-plugins-ugly:armhf \
            gstreamer1.0-libav \
            gstreamer1.0-libav:armhf
          
          # 安装开发文件
          GST_DEV_DEPS="\
            libgstreamer1.0-dev \
            libgstreamer1.0-dev:armhf \
            libgstreamer-plugins-base1.0-dev \
            libgstreamer-plugins-base1.0-dev:armhf \
            libgstreamer-plugins-good1.0-dev \
            libgstreamer-plugins-good1.0-dev:armhf \
            libgstreamer-plugins-bad1.0-dev \
            libgstreamer-plugins-bad1.0-dev:armhf"
          
          for pkg in $GST_DEV_DEPS; do
            echo "安装 GStreamer 开发包: $pkg"
            sudo apt install -y --allow-downgrades --allow-remove-essential --allow-change-held-packages "$pkg" || echo "跳过有问题的包: $pkg"
          done
          
          # 安装多媒体编解码器开发文件
          CODEC_DEV_DEPS="\
            libmpg123-dev \
            libmpg123-dev:armhf \
            libopenal-dev \
            libopenal-dev:armhf \
            libfaad-dev \
            libfaad-dev:armhf \
            libflac-dev \
            libflac-dev:armhf \
            libvorbis-dev \
            libvorbis-dev:armhf \
            libx264-dev \
            libx264-dev:armhf \
            libx265-dev \
            libx265-dev:armhf \
            libvpx-dev \
            libvpx-dev:armhf \
            libtheora-dev \
            libtheora-dev:armhf \
            libavcodec-dev \
            libavcodec-dev:armhf \
            libavformat-dev \
            libavformat-dev:armhf \
            libavutil-dev \
            libavutil-dev:armhf \
            libswscale-dev \
            libswscale-dev:armhf"
          
          for pkg in $CODEC_DEV_DEPS; do
            echo "安装编解码器开发包: $pkg"
            sudo apt install -y --allow-downgrades --allow-remove-essential --allow-change-held-packages "$pkg" || echo "跳过有问题的包: $pkg"
          done
          
          echo "GStreamer 依赖安装完成"

      - name: 修复 GStreamer pkgconfig 问题
        run: |
          echo "修复 GStreamer pkgconfig 问题..."
          
          # 查找所有可能的 pkgconfig 目录
          echo "查找所有 GStreamer pkgconfig 文件..."
          find /usr -name "*.pc" 2>/dev/null | grep gstreamer | head -10
          
          # 检查 64 位 gstreamer-plugins-base-1.0.pc 是否存在
          if [ ! -f "/usr/lib/aarch64-linux-gnu/pkgconfig/gstreamer-plugins-base-1.0.pc" ]; then
            echo "64 位 gstreamer-plugins-base-1.0.pc 不存在，尝试修复..."
            
            # 查找可能的位置
            ALT_LOCATION=$(find /usr -name "gstreamer-plugins-base-1.0.pc" 2>/dev/null | grep -v arm-linux-gnueabihf | head -1)
            if [ -n "$ALT_LOCATION" ]; then
              echo "在其他位置找到: $ALT_LOCATION"
              # 创建符号链接
              sudo mkdir -p /usr/lib/aarch64-linux-gnu/pkgconfig
              sudo ln -sf "$ALT_LOCATION" "/usr/lib/aarch64-linux-gnu/pkgconfig/gstreamer-plugins-base-1.0.pc"
              echo "已创建符号链接"
            else
              echo "错误: 无法找到 64 位 gstreamer-plugins-base-1.0.pc 文件"
              # 尝试重新安装包
              sudo apt install --reinstall -y libgstreamer-plugins-base1.0-dev
            fi
          fi
          
          # 验证修复结果
          echo "验证修复后的 GStreamer pkgconfig:"
          PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig" pkg-config --exists gstreamer-plugins-base-1.0 && echo "gstreamer-plugins-base-1.0 找到" || echo "gstreamer-plugins-base-1.0 未找到"

      - name: 验证 GStreamer 安装
        run: |
          echo "验证 GStreamer 开发文件..."
          
          # 设置完整的 PKG_CONFIG_PATH
          export PKG_CONFIG_PATH_64="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
          export PKG_CONFIG_PATH_32="/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
          
          echo "检查 64 位 GStreamer 开发文件:"
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_64" pkg-config --cflags gstreamer-1.0
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_64" pkg-config --cflags gstreamer-plugins-base-1.0
          
          echo "检查 32 位 GStreamer 开发文件:"
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_32" pkg-config --cflags gstreamer-1.0
          PKG_CONFIG_PATH="$PKG_CONFIG_PATH_32" pkg-config --cflags gstreamer-plugins-base-1.0

      - name: 安装 SDL2 开发依赖
        run: |
                sudo apt update
                echo "安装 SDL2 开发文件..."
    
                # 安装 SDL2 开发包（64位和32位）
                sudo apt install -y \
                  libsdl2-dev \
                  libsdl2-dev:armhf \
                  libsdl2-2.0-0 \
                  libsdl2-2.0-0:armhf \
                  libsdl2-image-dev \
                  libsdl2-image-dev:armhf \
                  libsdl2-ttf-dev \
                  libsdl2-ttf-dev:armhf \
                  libsdl2-mixer-dev \
                  libsdl2-mixer-dev:armhf
    
                echo "验证 SDL2 安装..."
                pkg-config --cflags sdl2
                pkg-config --libs sdl2

      - name: 设置交叉编译环境
        run: |
          # 创建交叉编译工具链符号链接
          sudo ln -sf /usr/bin/arm-linux-gnueabihf-gcc /usr/local/bin/arm-linux-gnueabihf-gcc
          sudo ln -sf /usr/bin/arm-linux-gnueabihf-g++ /usr/local/bin/arm-linux-gnueabihf-g++
          
          # 验证工具链
          echo "验证交叉编译工具链:"
          arm-linux-gnueabihf-gcc --version

      - name: 设置中文语言环境
        run: |
          sudo locale-gen zh_CN.UTF-8
          sudo update-locale LANG=zh_CN.UTF-8
          export LANG=zh_CN.UTF-8
          export LC_ALL=zh_CN.UTF-8

      - name: 设置编译环境
        run: |
          # 设置更宽松的 ulimit
          ulimit -s unlimited
          ulimit -n 65536
          
          # 显示系统资源
          echo "系统资源:"
          free -h
          df -h
          nproc
          cat /proc/meminfo | grep MemTotal

      - name: 构建 Wine ARM64 WOW64 版本
        run: |
          set -e
          
          # 设置环境变量
          export WINE_BRANCH="${{ github.event.inputs.wine_branch || 'staging' }}"
          export WINE_VERSION="${{ github.event.inputs.wine_version || 'latest' }}"
          export BUILD_DIR="/tmp/build_wine_${WINE_BRANCH}_${WINE_VERSION}"
          
          echo "开始构建 Wine ARM64 WOW64 版本..."
          echo "分支: $WINE_BRANCH"
          echo "版本: $WINE_VERSION"
          
          # 设置中文构建环境
          export LANG=zh_CN.UTF-8
          export LC_ALL=zh_CN.UTF-8
          export LANGUAGE=zh_CN:zh:en_US:en
          
          # 清理并创建构建目录
          rm -rf "$BUILD_DIR"
          mkdir -p "$BUILD_DIR"
          cd "$BUILD_DIR"
          
          # 根据分支获取 Wine 源码
          if [ "$WINE_BRANCH" = "staging-tkg" ] || [ "$WINE_BRANCH" = "staging-tkg-fsync" ]; then
            # TKG 系列处理
            echo "处理 TKG 系列分支: $WINE_BRANCH"
            
            if [ "$WINE_BRANCH" = "staging-tkg" ]; then
              git clone --depth=1 https://github.com/Kron4ek/wine-tkg.git wine-tkg
              SOURCE_DIR="wine-tkg"
            else
              git clone --depth=1 --branch fsync https://github.com/Kron4ek/wine-tkg.git wine-tkg
              SOURCE_DIR="wine-tkg"
            fi
            
            cd "$SOURCE_DIR"
            
            if [ "$WINE_VERSION" != "latest" ]; then
              if git checkout "$WINE_VERSION" 2>/dev/null || git checkout "wine-$WINE_VERSION" 2>/dev/null; then
                echo "成功切换到版本 $WINE_VERSION"
              else
                echo "使用默认分支"
              fi
            fi
            
            if [ -f "VERSION" ]; then
              WINE_VERSION_ACTUAL="$(cat VERSION | tail -c +14)"
              echo "从 VERSION 文件获取版本: $WINE_VERSION_ACTUAL"
            else
              WINE_VERSION_ACTUAL=$(git describe --tags --abbrev=0 2>/dev/null || echo "$WINE_VERSION")
              echo "从 git 标签获取版本: $WINE_VERSION_ACTUAL"
            fi
            
            COMMIT_HASH=$(git rev-parse --short HEAD)
            BUILD_NAME="wine-${WINE_VERSION_ACTUAL}-${WINE_BRANCH}-arm64-wow64"
            
          elif [ "$WINE_BRANCH" = "staging" ]; then
            # staging 分支处理
            echo "处理 Staging 分支"
            git clone --depth=1 https://github.com/wine-mirror/wine.git wine
            SOURCE_DIR="wine"
            cd "$SOURCE_DIR"
            
            git config advice.detachedHead false
            
            if [ "$WINE_VERSION" != "latest" ]; then
              git checkout "wine-$WINE_VERSION"
            fi
            WINE_VERSION_ACTUAL=$(git describe --tags --abbrev=0 2>/dev/null || echo "$WINE_VERSION")
            COMMIT_HASH=$(git rev-parse --short HEAD)
            BUILD_NAME="wine-${WINE_VERSION_ACTUAL}-${COMMIT_HASH}-staging-arm64-wow64"
            
          elif [ "$WINE_BRANCH" = "vanilla" ]; then
            # vanilla 分支处理
            echo "处理 Vanilla 分支"
            git clone --depth=1 https://github.com/wine-mirror/wine.git wine
            SOURCE_DIR="wine"
            cd "$SOURCE_DIR"
            
            git config advice.detachedHead false
            
            if [ "$WINE_VERSION" != "latest" ]; then
              git checkout "wine-$WINE_VERSION"
            fi
            WINE_VERSION_ACTUAL=$(git describe --tags --abbrev=0 2>/dev/null || echo "$WINE_VERSION")
            COMMIT_HASH=$(git rev-parse --short HEAD)
            BUILD_NAME="wine-${WINE_VERSION_ACTUAL}-${COMMIT_HASH}-vanilla-arm64-wow64"
            
          else
            echo "未知的 Wine 分支: $WINE_BRANCH"
            exit 1
          fi
          
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "当前源码目录: $(pwd)"
          echo "构建名称: $BUILD_NAME"
          
          # 生成 configure 脚本
          echo "生成 configure 脚本..."
          ./autogen.sh
          
          # 第一步：构建 64 位 Wine
          echo "=== 构建 64 位 Wine ==="
          mkdir -p build64
          cd build64
          
          # 使用原生编译器
          export CC=gcc
          export CXX=g++
          export CFLAGS="-march=armv8-a+crc+crypto -O3 -g -pipe -Wall -Wextra -fPIC"
          export CXXFLAGS="-march=armv8-a+crc+crypto -O3 -g -pipe -Wall -Wextra -fPIC"
          export MAKEFLAGS="-j2"
          
          # 设置完整的 PKG_CONFIG_PATH
          export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
          
          echo "PKG_CONFIG_PATH: $PKG_CONFIG_PATH"
          echo "测试 GStreamer pkg-config:"
          pkg-config --cflags gstreamer-1.0 || echo "gstreamer-1.0 未找到"
          pkg-config --cflags gstreamer-plugins-base-1.0 || echo "gstreamer-plugins-base-1.0 未找到"
          
          # 配置 64 位 Wine - 使用原生配置
          ../configure \
            --prefix=/tmp/wine-install-wow64 \
            --enable-win64 \
            --with-x \
            --with-alsa \
            --with-pulse \
            --with-freetype \
            --with-fontconfig \
            --with-gstreamer \
            --with-gettext \
            --with-sdl \
            --enable-nls \
            --disable-winemenubuilder \
            --disable-win16 \
            --disable-tests \
            --without-ldap \
            --without-capi \
            --without-oss \
            --without-cups \
            --without-dbus \
            --without-coreaudio \
            --without-gphoto \
            --without-osmesa \
            --without-sane \
            --without-pcap \
            --without-pcsclite \
            --without-udev \
            --without-unwind \
            --without-usb \
            --without-v4l2 \
            --without-wayland
          
          echo "编译 64 位 Wine..."
          make -j2 install > make64.log 2>&1 || (echo "64位编译失败，查看日志..." && tail -100 make64.log && make -j1 install > make64_single.log 2>&1 || (tail -100 make64_single.log && exit 1))
          
          cd ..
          
          # 第二步：构建 32 位 Wine
          echo "=== 构建 32 位 Wine ==="
          mkdir -p build32
          cd build32
          
          # 对于 32 位构建，使用交叉编译器
          export CC=arm-linux-gnueabihf-gcc
          export CXX=arm-linux-gnueabihf-g++
          export CFLAGS="-march=armv8-a -O3 -g -pipe -Wall -Wextra -fPIC"
          export CXXFLAGS="-march=armv8-a -O3 -g -pipe -Wall -Wextra -fPIC"
          export MAKEFLAGS="-j2"
          
          # 设置 32 位的 PKG_CONFIG_PATH
          export PKG_CONFIG_PATH="/usr/lib/arm-linux-gnueabihf/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig"
          export PKG_CONFIG="pkg-config --define-variable=libdir=/usr/lib/arm-linux-gnueabihf"
          
          echo "PKG_CONFIG_PATH for 32-bit: $PKG_CONFIG_PATH"
          echo "测试 GStreamer pkg-config:"
          pkg-config --cflags gstreamer-1.0 || echo "gstreamer-1.0 未找到"
          pkg-config --cflags gstreamer-plugins-base-1.0 || echo "gstreamer-plugins-base-1.0 未找到"
          
          # 配置 32 位 Wine，指向已安装的 64 位版本
          ../configure \
            --build=arm-linux-gnueabihf \
            --host=arm-linux-gnueabihf \
            --with-wine64=../build64 \
            --with-x \
            --with-alsa \
            --with-pulse \
            --with-freetype \
            --with-fontconfig \
            --with-gstreamer \
            --disable-winemenubuilder \
            --disable-win16 \
            --disable-tests \
            --without-ldap \
            --without-capi \
            --without-oss \
            --without-cups \
            --without-dbus \
            --without-coreaudio \
            --without-gphoto \
            --without-osmesa \
            --without-sane \
            --without-pcap \
            --without-pcsclite \
            --without-udev \
            --without-unwind \
            --without-usb \
            --without-v4l2 \
            --without-wayland
          
          echo "编译 32 位 Wine..."
          make -j2 install > make32.log 2>&1 || (echo "32位编译失败，查看日志..." && tail -100 make32.log && make -j1 install > make32_single.log 2>&1 || (tail -100 make32_single.log && exit 1))
          
          echo "ARM64 WOW64 Wine 构建完成"

      - name: 准备打包
        run: |
          # 创建打包目录
          PACKAGE_NAME="${{ env.BUILD_NAME }}"
          mkdir -p wine-package/$PACKAGE_NAME
          
          # 检查源目录是否存在
          if [ -d "/tmp/wine-install-wow64" ]; then
            echo "复制 Wine 文件到 $PACKAGE_NAME..."
            cp -r /tmp/wine-install-wow64/* wine-package/$PACKAGE_NAME/ || echo "复制文件时出现问题"
          else
            echo "错误: 源目录 /tmp/wine-install-wow64 不存在"
            exit 1
          fi

      - name: 创建打包文件
        run: |
          PACKAGE_NAME="${{ env.BUILD_NAME }}"
          
          echo "检查打包目录内容:"
          if [ -d "wine-package/$PACKAGE_NAME" ]; then
            echo "最终文件结构:"
            find "wine-package/$PACKAGE_NAME" -type f | head -20
            echo "目录大小:"
            du -sh "wine-package/$PACKAGE_NAME"
            
            # 使用 tar.xz 格式打包
            tar -cJf "$PACKAGE_NAME.tar.xz" -C wine-package "$PACKAGE_NAME"
            
            echo "打包完成:"
            ls -lh *.tar.xz
          else
            echo "错误: 打包目录 wine-package/$PACKAGE_NAME 不存在"
            exit 1
          fi

      - name: Generate checksums
        run: |
          cd $GITHUB_WORKSPACE
          sha256sum *.tar.xz > checksums.txt
          cat checksums.txt

      - name: Upload Wine ARM64 WoW64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Wine-${{ github.event.inputs.wine_branch || 'staging' }}-${{ github.event.inputs.wine_version || 'latest' }}-ARM64-WoW64
          path: |
            ${{ github.workspace }}/*.tar.xz
            ${{ github.workspace }}/checksums.txt
          retention-days: 30

      - name: 发布 Wine 到 GitHub Release
        uses: softprops/action-gh-release@v1
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_type == 'wine-wow64'
        with:
          tag_name: wine-${{ github.event.inputs.wine_branch || 'staging' }}-${{ github.event.inputs.wine_version || 'latest' }}-arm64-wow64
          name: Wine ${{ github.event.inputs.wine_branch || 'staging' }} ${{ github.event.inputs.wine_version || 'latest' }} (ARM64 WOW64 with Vulkan & GStreamer for Termux)
          body: |
            # Wine ${{ github.event.inputs.wine_branch || 'staging' }} ${{ github.event.inputs.wine_version || 'latest' }} - ARM64 WOW64 with Vulkan & GStreamer for Termux
            
            ## 版本信息
            - **Wine 分支**: ${{ github.event.inputs.wine_branch || 'staging' }}
            - **Wine 版本**: ${{ github.event.inputs.wine_version || 'latest' }}
            - **架构**: ARM64 WOW64 (在 ARM64 设备上运行 32 位和 64 位 Windows 应用程序)
            - **平台**: Termux (Android ARM64)
            - **图形 API**: Vulkan 支持已启用
            - **多媒体**: 完整 GStreamer 支持
            
            ## 特性
            ✓ ARM64 原生架构
            ✓ WOW64 支持 (在 ARM64 上运行 32 位和 64 位 Windows 应用程序)
            ✓ Vulkan 图形 API 支持
            ✓ 完整的 GStreamer 支持
            ✓ 中文环境支持
            ✓ 针对 ARM64 架构优化编译
            
            ## 安装说明
            解压后，将 `${{ env.BUILD_NAME }}` 文件夹放置在 Termux 的合适位置，并设置环境变量。

            ## 构建信息
            - 构建时间: ${{ github.event.head_commit.timestamp }}
            - 提交: ${{ github.sha }}
            - 工作流: ${{ github.workflow }}
          files: |
            ${{ github.workspace }}/${{ env.BUILD_NAME }}.tar.xz
            ${{ github.workspace }}/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}